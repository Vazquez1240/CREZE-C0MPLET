{"ast":null,"code":"import { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim\";\nfunction createReaction(adm) {\n  adm.reaction = new Reaction(\"observer\".concat(adm.name), function () {\n    var _a;\n    adm.stateVersion = Symbol();\n    // onStoreChange won't be available until the component \"mounts\".\n    // If state changes in between initial render and mount,\n    // `useSyncExternalStore` should handle that by checking the state version and issuing update.\n    (_a = adm.onStoreChange) === null || _a === void 0 ? void 0 : _a.call(adm);\n  });\n}\nexport function useObserver(render, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n  if (isUsingStaticRendering()) {\n    return render();\n  }\n  var admRef = React.useRef(null);\n  if (!admRef.current) {\n    // First render\n    var adm_1 = {\n      reaction: null,\n      onStoreChange: null,\n      stateVersion: Symbol(),\n      name: baseComponentName,\n      subscribe: function (onStoreChange) {\n        // Do NOT access admRef here!\n        observerFinalizationRegistry.unregister(adm_1);\n        adm_1.onStoreChange = onStoreChange;\n        if (!adm_1.reaction) {\n          // We've lost our reaction and therefore all subscriptions, occurs when:\n          // 1. Timer based finalization registry disposed reaction before component mounted.\n          // 2. React \"re-mounts\" same component without calling render in between (typically <StrictMode>).\n          // We have to recreate reaction and schedule re-render to recreate subscriptions,\n          // even if state did not change.\n          createReaction(adm_1);\n          // `onStoreChange` won't force update if subsequent `getSnapshot` returns same value.\n          // So we make sure that is not the case\n          adm_1.stateVersion = Symbol();\n        }\n        return function () {\n          var _a;\n          // Do NOT access admRef here!\n          adm_1.onStoreChange = null;\n          (_a = adm_1.reaction) === null || _a === void 0 ? void 0 : _a.dispose();\n          adm_1.reaction = null;\n        };\n      },\n      getSnapshot: function () {\n        // Do NOT access admRef here!\n        return adm_1.stateVersion;\n      }\n    };\n    admRef.current = adm_1;\n  }\n  var adm = admRef.current;\n  if (!adm.reaction) {\n    // First render or reaction was disposed by registry before subscribe\n    createReaction(adm);\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    observerFinalizationRegistry.register(admRef, adm, adm);\n  }\n  React.useDebugValue(adm.reaction, printDebugValue);\n  useSyncExternalStore(\n  // Both of these must be stable, otherwise it would keep resubscribing every render.\n  adm.subscribe, adm.getSnapshot, adm.getSnapshot);\n  // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n  var renderResult;\n  var exception;\n  adm.reaction.track(function () {\n    try {\n      renderResult = render();\n    } catch (e) {\n      exception = e;\n    }\n  });\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n  return renderResult;\n}","map":{"version":3,"names":["Reaction","React","printDebugValue","isUsingStaticRendering","observerFinalizationRegistry","useSyncExternalStore","createReaction","adm","reaction","concat","name","stateVersion","Symbol","_a","onStoreChange","call","useObserver","render","baseComponentName","admRef","useRef","current","adm_1","subscribe","unregister","dispose","getSnapshot","register","useDebugValue","renderResult","exception","track","e"],"sources":["/home/martin/Escritorio/soporte-creze/frontend/creze-frontend/node_modules/mobx-react-lite/src/useObserver.ts"],"sourcesContent":["import { Reaction } from \"mobx\"\nimport React from \"react\"\nimport { printDebugValue } from \"./utils/printDebugValue\"\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\"\nimport { useSyncExternalStore } from \"use-sync-external-store/shim\"\n\n// Do not store `admRef` (even as part of a closure!) on this object,\n// otherwise it will prevent GC and therefore reaction disposal via FinalizationRegistry.\ntype ObserverAdministration = {\n    reaction: Reaction | null // also serves as disposed flag\n    onStoreChange: Function | null // also serves as mounted flag\n    // stateVersion that 'ticks' for every time the reaction fires\n    // tearing is still present,\n    // because there is no cross component synchronization,\n    // but we can use `useSyncExternalStore` API.\n    // TODO: optimize to use number?\n    stateVersion: any\n    name: string\n    // These don't depend on state/props, therefore we can keep them here instead of `useCallback`\n    subscribe: Parameters<typeof React.useSyncExternalStore>[0]\n    getSnapshot: Parameters<typeof React.useSyncExternalStore>[1]\n}\n\nfunction createReaction(adm: ObserverAdministration) {\n    adm.reaction = new Reaction(`observer${adm.name}`, () => {\n        adm.stateVersion = Symbol()\n        // onStoreChange won't be available until the component \"mounts\".\n        // If state changes in between initial render and mount,\n        // `useSyncExternalStore` should handle that by checking the state version and issuing update.\n        adm.onStoreChange?.()\n    })\n}\n\nexport function useObserver<T>(render: () => T, baseComponentName: string = \"observed\"): T {\n    if (isUsingStaticRendering()) {\n        return render()\n    }\n\n    const admRef = React.useRef<ObserverAdministration | null>(null)\n\n    if (!admRef.current) {\n        // First render\n        const adm: ObserverAdministration = {\n            reaction: null,\n            onStoreChange: null,\n            stateVersion: Symbol(),\n            name: baseComponentName,\n            subscribe(onStoreChange: () => void) {\n                // Do NOT access admRef here!\n                observerFinalizationRegistry.unregister(adm)\n                adm.onStoreChange = onStoreChange\n                if (!adm.reaction) {\n                    // We've lost our reaction and therefore all subscriptions, occurs when:\n                    // 1. Timer based finalization registry disposed reaction before component mounted.\n                    // 2. React \"re-mounts\" same component without calling render in between (typically <StrictMode>).\n                    // We have to recreate reaction and schedule re-render to recreate subscriptions,\n                    // even if state did not change.\n                    createReaction(adm)\n                    // `onStoreChange` won't force update if subsequent `getSnapshot` returns same value.\n                    // So we make sure that is not the case\n                    adm.stateVersion = Symbol()\n                }\n\n                return () => {\n                    // Do NOT access admRef here!\n                    adm.onStoreChange = null\n                    adm.reaction?.dispose()\n                    adm.reaction = null\n                }\n            },\n            getSnapshot() {\n                // Do NOT access admRef here!\n                return adm.stateVersion\n            }\n        }\n\n        admRef.current = adm\n    }\n\n    const adm = admRef.current!\n\n    if (!adm.reaction) {\n        // First render or reaction was disposed by registry before subscribe\n        createReaction(adm)\n        // StrictMode/ConcurrentMode/Suspense may mean that our component is\n        // rendered and abandoned multiple times, so we need to track leaked\n        // Reactions.\n        observerFinalizationRegistry.register(admRef, adm, adm)\n    }\n\n    React.useDebugValue(adm.reaction!, printDebugValue)\n\n    useSyncExternalStore(\n        // Both of these must be stable, otherwise it would keep resubscribing every render.\n        adm.subscribe,\n        adm.getSnapshot,\n        adm.getSnapshot\n    )\n\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    let renderResult!: T\n    let exception\n    adm.reaction!.track(() => {\n        try {\n            renderResult = render()\n        } catch (e) {\n            exception = e\n        }\n    })\n\n    if (exception) {\n        throw exception // re-throw any exceptions caught during rendering\n    }\n\n    return renderResult\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,MAAM;AAC/B,OAAOC,KAAK,MAAM,OAAO;AACzB,SAASC,eAAe,QAAQ,yBAAyB;AACzD,SAASC,sBAAsB,QAAQ,mBAAmB;AAC1D,SAASC,4BAA4B,QAAQ,sCAAsC;AACnF,SAASC,oBAAoB,QAAQ,8BAA8B;AAmBnE,SAASC,cAAcA,CAACC,GAA2B;EAC/CA,GAAG,CAACC,QAAQ,GAAG,IAAIR,QAAQ,CAAC,WAAAS,MAAA,CAAWF,GAAG,CAACG,IAAI,CAAE,EAAE;;IAC/CH,GAAG,CAACI,YAAY,GAAGC,MAAM,EAAE;IAC3B;IACA;IACA;IACA,CAAAC,EAAA,GAAAN,GAAG,CAACO,aAAa,cAAAD,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAAR,GAAA,CAAI;EACzB,CAAC,CAAC;AACN;AAEA,OAAM,SAAUS,WAAWA,CAAIC,MAAe,EAAEC,iBAAsC;EAAtC,IAAAA,iBAAA;IAAAA,iBAAA,aAAsC;EAAA;EAClF,IAAIf,sBAAsB,EAAE,EAAE;IAC1B,OAAOc,MAAM,EAAE;;EAGnB,IAAME,MAAM,GAAGlB,KAAK,CAACmB,MAAM,CAAgC,IAAI,CAAC;EAEhE,IAAI,CAACD,MAAM,CAACE,OAAO,EAAE;IACjB;IACA,IAAMC,KAAG,GAA2B;MAChCd,QAAQ,EAAE,IAAI;MACdM,aAAa,EAAE,IAAI;MACnBH,YAAY,EAAEC,MAAM,EAAE;MACtBF,IAAI,EAAEQ,iBAAiB;MACvBK,SAAS,WAAAA,CAACT,aAAyB;QAC/B;QACAV,4BAA4B,CAACoB,UAAU,CAACF,KAAG,CAAC;QAC5CA,KAAG,CAACR,aAAa,GAAGA,aAAa;QACjC,IAAI,CAACQ,KAAG,CAACd,QAAQ,EAAE;UACf;UACA;UACA;UACA;UACA;UACAF,cAAc,CAACgB,KAAG,CAAC;UACnB;UACA;UACAA,KAAG,CAACX,YAAY,GAAGC,MAAM,EAAE;;QAG/B,OAAO;;UACH;UACAU,KAAG,CAACR,aAAa,GAAG,IAAI;UACxB,CAAAD,EAAA,GAAAS,KAAG,CAACd,QAAQ,cAAAK,EAAA,uBAAAA,EAAA,CAAEY,OAAO,EAAE;UACvBH,KAAG,CAACd,QAAQ,GAAG,IAAI;QACvB,CAAC;MACL,CAAC;MACDkB,WAAW,WAAAA,CAAA;QACP;QACA,OAAOJ,KAAG,CAACX,YAAY;MAC3B;KACH;IAEDQ,MAAM,CAACE,OAAO,GAAGC,KAAG;;EAGxB,IAAMf,GAAG,GAAGY,MAAM,CAACE,OAAQ;EAE3B,IAAI,CAACd,GAAG,CAACC,QAAQ,EAAE;IACf;IACAF,cAAc,CAACC,GAAG,CAAC;IACnB;IACA;IACA;IACAH,4BAA4B,CAACuB,QAAQ,CAACR,MAAM,EAAEZ,GAAG,EAAEA,GAAG,CAAC;;EAG3DN,KAAK,CAAC2B,aAAa,CAACrB,GAAG,CAACC,QAAS,EAAEN,eAAe,CAAC;EAEnDG,oBAAoB;EAChB;EACAE,GAAG,CAACgB,SAAS,EACbhB,GAAG,CAACmB,WAAW,EACfnB,GAAG,CAACmB,WAAW,CAClB;EAED;EACA;EACA;EACA,IAAIG,YAAgB;EACpB,IAAIC,SAAS;EACbvB,GAAG,CAACC,QAAS,CAACuB,KAAK,CAAC;IAChB,IAAI;MACAF,YAAY,GAAGZ,MAAM,EAAE;KAC1B,CAAC,OAAOe,CAAC,EAAE;MACRF,SAAS,GAAGE,CAAC;;EAErB,CAAC,CAAC;EAEF,IAAIF,SAAS,EAAE;IACX,MAAMA,SAAS,EAAC;;EAGpB,OAAOD,YAAY;AACvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}